<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (subprocess.index)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">Index</a> &#x00BB; subprocess</nav><header class="odoc-preamble"><h2 id="subprocess:-abstractions-for-io-with-unix-processes"><a href="#subprocess:-abstractions-for-io-with-unix-processes" class="anchor"></a>Subprocess: abstractions for IO with unix processes</h2><p><a href="Subprocess/index.html"><code>Subprocess</code></a> is a module which attempts to make working with unix processes in OCaml safer and simpler (in that order).</p><p>This package can be installed with <a href="https://ocaml.org/p/subprocess/latest">opam</a>.</p><p>The project homepage is <a href="https://github.com/ninjaaron/ocaml-subprocess">https://github.com/ninjaaron/ocaml-subprocess</a>.</p><p>The API reference can be accessed by clicking literally any highlighted instance of the word <a href="Subprocess/index.html"><code>Subprocess</code></a>, and there are a lot of those.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#safety-features">Safety features</a><ul><li><a href="#no-shell">No Shell</a></li><li><a href="#non-zero-exit-status-is-(normally)-an-error">Non-zero exit status is (normally) an error</a></li><li><a href="#cleanup-is-abstracted">Cleanup is abstracted</a></li></ul></li><li><a href="#extras">Extras</a><ul><li><a href="#opt-in-non-blocking-io">Opt-in non-blocking IO</a></li></ul></li><li><a href="#introductory-examples">Introductory examples</a><ul><li><a href="#commands">Commands</a></li><li><a href="#execution-helpers">Execution Helpers</a><ul><li><a href="#on-the-benefits-of-expressive-types"><i>on the benefits of expressive types</i></a></li></ul></li><li><a href="#interacting-with-running-processes-(or-exec-and-let&amp;)">Interacting with Running Processes (or <code>exec</code> and <code>let&amp;</code>)</a><ul><li><a href="#creating-process-pipelines">creating process pipelines</a></li></ul></li><li><a href="#passing-around-processes">Passing around processes</a></li><li><a href="#non-blocking-i/o-or-&quot;working-with-multiple-pipes-for-one-process&quot;">Non-blocking I/O <i>or &quot;working with multiple pipes for one process&quot;</i></a></li></ul></li></ul></nav></div><div class="odoc-content"><h4 id="safety-features"><a href="#safety-features" class="anchor"></a>Safety features</h4><p>Several features are included in <a href="Subprocess/index.html"><code>Subprocess</code></a> to improve the safety and correctness of programs which launch other programs. It is not perfect in this regard, but it does try to alleviate many of the common pitfalls when working with processes.</p><h5 id="no-shell"><a href="#no-shell" class="anchor"></a>No Shell</h5><p>Commands in <a href="Subprocess/index.html"><code>Subprocess</code></a> never receive a shell. We've had enough injection CEVs in the past several decades that it's time to stop giving our commands a shell. I realize redirection tends to be a bit easier to be a bit easier with a shell, but Subprocess provides combinators to make it as easy as possible (but no easier!) to do IO redirection--and indeed, this is the main point of the library.</p><p>The user is, of course free to do the equivalent of <code>/bin/sh -c &quot;echo foo&quot;</code>, i.e. <code>Subprocess.cmd [&quot;/bin/sh&quot;; &quot;-c&quot;; &quot;echo foo&quot;]</code> but it's your own affair at that point--and you're probably better off using functions provided by the standard library or the <code>Unix</code> library--but I believe you will find that <a href="Subprocess/index.html"><code>Subprocess</code></a> provides a better way to do most things.</p><h5 id="non-zero-exit-status-is-(normally)-an-error"><a href="#non-zero-exit-status-is-(normally)-an-error" class="anchor"></a>Non-zero exit status is (normally) an error</h5><p>Another &quot;feature not a bug&quot; of Subprocess is that, by default, a non-zero exit status is considered a failure and will produce an error in OCaml. In the top-level functions of the <a href="Subprocess/index.html"><code>Subprocess</code></a> module, this means raising an exception. If you, like me, prefer to handle errors with result types, the <a href="Subprocess/Results/index.html"><code>Subprocess.Results</code></a> module is provided to represent non-zero exit status as an <code>Error of</code> <a href="Subprocess/Core/Exit/index.html#type-t"><code>Subprocess.Exit.t</code></a>. A combinator is provided convert this to <code>Error of string</code> for better composition with other result types in the context of monadic binding. If you don't need the exit status at all, there is also a <a href="Subprocess/StringResults/index.html"><code>Subprocess.StringResults</code></a> module which only deals in <code>Error of string</code></p><p>I consider treating non-zero exit status as an error to be a &quot;sane default&quot; like using <code>set -eo pipefail</code> in a bash script is a sane default. However, I realize that a non-zero exit status is not always an error, and for this, the <a href="Subprocess/Unchecked/index.html"><code>Subprocess.Unchecked</code></a> module is provided. This module is also useful if you are interested in the output of a process regardless of the exit status.</p><h5 id="cleanup-is-abstracted"><a href="#cleanup-is-abstracted" class="anchor"></a>Cleanup is abstracted</h5><p>Subprocess attempts to avoid making the user handle closing processes and pipes explicitly by providing several functions which simply read process output, close all pipes and wait for the process to exit before returning the output (or error). There is also family of fold functions which fold over line output from a running process, but clean everything up before returning.</p><p>For running process interaction, the running process is passed to a user-provided function and everything is properly closed when the function exits--either by being fully evaluated or by raising an exception.</p><p>If for some reason you need to pass around a live process in a wider context, <a href="Subprocess/Exec/index.html#val-exec"><code>Subprocess.Exec.exec</code></a> makes this possible, but you have to clean up your own mess at that point.</p><h4 id="extras"><a href="#extras" class="anchor"></a>Extras</h4><p>Subprocess generally does not use many any opaque types and practically everything has a pretty printer for easier debugging. The lack of opaque types is not an <i>invitation</i> to go digging into the implementation details <i>which are subject to change</i>, but rather an acknowledgment that no abstraction is perfect and there may at times valid reasons to dig into them.</p><h5 id="opt-in-non-blocking-io"><a href="#opt-in-non-blocking-io" class="anchor"></a>Opt-in non-blocking IO</h5><p>Subprocess supports non-blocking IO, but it does not provide direct compatibility layers with popular OCaml asynchronous IO libraries like lwt and eio, which typically provide their own process abstractions. Neither does Subprocess provide its own event loop. The user must handle non-blocking IO operations and process polling manually where non-blocking behavior is desired. It is not different from handling non-blocking IO in the OCaml standard library and examples will be provided here where relevant.</p><p>Perhaps compatibility with lwt and / or eio will be a goal for a future version of Subprocess.</p><h3 id="introductory-examples"><a href="#introductory-examples" class="anchor"></a>Introductory examples</h3><h4 id="commands"><a href="#commands" class="anchor"></a>Commands</h4><p>The most fundamental abstraction in Subprocess is <a href="Subprocess/Core/Cmd/index.html#type-t"><code>Subprocess.Cmd.t</code></a> It is simply a data representation of a yet-to-be-executed command, and contains information about arguments, I/O redirection, environment variables and blocking.</p><pre class="language-ocaml"><code>  # open Subprocess;;
  # let my_cmd = cmd [&quot;echo&quot;; &quot;foo&quot;];;
  val my_cmd : (stdin, stdout, stderr) Cmd.t = cmd(`echo foo`)
  # Format.printf &quot;%a\n&quot; Cmd.pp my_cmd;;
  cmd(`echo foo`)</code></pre><p>As you can see, the command also has type parameters related to each of the standard streams, which both gives us more information as programmers, but also turns certain failure cases for I/O into type errors.</p><p>A number of combinators are defined after <a href="Subprocess/Core/index.html#val-cmd"><code>Subprocess.Core.cmd</code></a> which may be used to redirect the standard streams, as well as set environment variables and use non-blocking I/O for pipes. <i>Subprocess will either unblock all pipes or none. More on that later.</i> I typically use the pipeline operator with this combinators because it &quot;feels right&quot;, but obviously you can use regular function application or the <code>@@</code> application operator.</p><p>For example:</p><pre class="language-ocaml"><code>(* similar to `my_cmd 2&gt; /dev/null` *)
# my_cmd |&gt; devnull_err;;
- : (stdin, stdout, devnull) Cmd.t = cmd(`echo foo`, stderr: /dev/null)
(* similar to `my_cmd &lt; input.txt *)
# my_cmd |&gt; file_in &quot;input.txt&quot;;;
- : (file, stdout, stderr) Cmd.t = cmd(`echo foo`, stdin: file &quot;input.txt&quot;)
(* similar to `USER=app my_cmd` *)
# my_cmd |&gt; env [&quot;USER=app&quot;];;
- : (stdin, stdout, stderr) Cmd.t = cmd(`echo foo`, env:[&quot;USER=app&quot;])</code></pre><p>One thing that cannot be expressed very well with these combinators is the shell idiom <code>2&gt;&amp;1</code>, which combines stdout and stderr into a single stream.</p><pre class="language-ocaml"><code># my_cmd |&gt; channel_err Out_channel.stdout;;
- : (stdin, stdout, channel) Cmd.t = cmd(`echo foo`, stderr: channel)</code></pre><p>This works well enough if your desire is that the output simply be printed, but we run into problems in this case:</p><pre class="language-ocaml"><code># my_cmd |&gt; channel_err Out_channel.stdout |&gt; pipe_out;;
- : (stdin, pipe, channel) Cmd.t =
cmd(`echo foo`, stdout: pipe, stderr: channel)`</code></pre><p>In this case, the child's stdout is redirected to a pipe, but stderr is still printed to the parent process's <code>stdout</code>.</p><p>What we have for this case is a family of execution helpers with <code>_joined</code> in the name such as <a href="Subprocess/index.html#val-read_joined"><code>Subprocess.read_joined</code></a>.</p><h4 id="execution-helpers"><a href="#execution-helpers" class="anchor"></a>Execution Helpers</h4><p>Note that we have not yet executed any process. These combinators simply produce a new instance of <code>Subprocess.Cmd.t</code>. How do we execute commands? There are a variety of helper functions for this.</p><pre class="language-ocaml"><code># run my_cmd;;
foo
- : unit = ()
# read my_cmd;;
- : string = &quot;foo\n&quot; 
# lines my_cmd;;
- : string list = [&quot;foo&quot;]
# fold my_cmd ~init:0 ~f:(fun acc line -&gt; acc + String.length line);;
- : int = 3</code></pre><p>There are many more such functions. See <a href="Subprocess/index.html#val-run"><code>Subprocess.run</code></a> and following for more. Remember that all the functions demonstrated here will throw an exception on non-zero exit status. However, they all have analogous versions in <a href="Subprocess/Results/index.html"><code>Subprocess.Results</code></a> and <a href="Subprocess/Unchecked/index.html"><code>Subprocess.Unchecked</code></a> which handle this case in different ways.</p><pre class="language-ocaml"><code># Results.read my_cmd;;
- : (string, Exit.t) result = Ok &quot;foo\n&quot;
# Unchecked.read my_cmd;;
- : Exit.t * string =
((exited: 0, pid: 13762, cmd(`echo foo`, stdout: pipe)), &quot;foo\n&quot;)</code></pre><p>If you look closely at the exit information in the previous example, you will also get a glimpse of how the sausage is made. <code>my_cmd</code> has its <code>stdout</code> set to the default (inheriting from the spawning process) but the <code>read</code> function sets it to <code>pipe</code> internally which is necessary to read the output into an OCaml string.</p><h5 id="on-the-benefits-of-expressive-types"><a href="#on-the-benefits-of-expressive-types" class="anchor"></a><i>on the benefits of expressive types</i></h5><p>As already seen, commands carry type-level information about their I/O streams. Whether you regard this as expressive or <i>excessive</i> may be a matter of taste, but a consequence of this is that not all commands instances are valid with all of these process executor functions.</p><pre class="language-ocaml"><code># read (my_cmd |&gt; file_out &quot;out.txt&quot;);;
Error: This expression has type (stdin, file, stderr) Cmd.t
       but an expression was expected of type (stdin, stdout, 'a) Cmd.t
       Type file is not compatible with type stdout</code></pre><p>Here, <code>stdout</code> would be redirected twice, and from the perspective of someone reading the code, this is ambiguous in its meaning. Rather than let inscrutable bugs creep into our code, we simply make such ambiguities unrepresentable.</p><h4 id="interacting-with-running-processes-(or-exec-and-let&amp;)"><a href="#interacting-with-running-processes-(or-exec-and-let&amp;)" class="anchor"></a>Interacting with Running Processes (or <code>exec</code> and <code>let&amp;</code>)</h4><p>At times you may wish to interact with a running process, reading from pipes iteratively or polling the process as you go. For iterating over output, you may use <code>Subprocess.fold</code> and related functions, as we have already seen. However as an illustrative example lets make the world's most inefficient capitalize function.</p><pre class="language-ocaml"><code># 
let capitalize str = 
  exec (cmd [&quot;tr&quot;; &quot;a-z&quot;; &quot;A-Z&quot;] |&gt; pipe_in |&gt; pipe_out)
    ~f:(fun proc -&gt;
      Out_channel.output_string (stdin proc) str;
      Out_channel.close (stdin proc);
      In_channel.input_all (stdout proc)
    );;
val capitalize : string -&gt; string = &lt;fun&gt;
# capitalize &quot;foo&quot;;;
- : string = &quot;FOO&quot;`</code></pre><p>Several important things here.</p><ul><li><code>Subprocess.exec</code> takes a command as input in addition to a function. The function will take a handle to the process as input and will automatically close everything when the function exits.</li><li><code>Subprocess.stdin</code> and <code>Subprocess.stdout</code> are functions which will return <code>output_channel</code> and <code>input_channel</code> respectively if these streams have been set to <code>pipe</code>. As you might expect, there is also a <code>Subprocess.stderr</code> function for accessing the process's stderr. Trying to access a stream that is not a pipe with these functions is simply a type error.</li><li>I/O with pipes is tricky. Though <code>exec</code> will automatically close any open pipes, it this we still have to explicitly <code>close</code> or <code>flush</code> stdin in this this case or reading from stdout will block because the string will just be sitting in a buffer otherwise.</li></ul><p>Also note that for longer inputs and outputs, we would want to use non-blocking I/O to avoid these kinds of problems--a good case for using <a href="Subprocess/index.html#val-fold_with"><code>Subprocess.fold_with</code></a>, which handles reads and writes asynchronously.</p><pre class="language-ocaml"><code># 
let capitalize str =
  fold_with (cmd [&quot;tr&quot;; &quot;a-z&quot;; &quot;A-Z&quot;]) ~lines:(Seq.return str) ~init:&quot;&quot;
    ~f:( ^ );;
val capitalize : string -&gt; string = &lt;fun&gt;
# capitalize &quot;foo&quot;;;
- : string = &quot;FOO&quot;</code></pre><h5 id="creating-process-pipelines"><a href="#creating-process-pipelines" class="anchor"></a>creating process pipelines</h5><p>To simplify creating pipelines, <code>let&amp;</code> another way to execute commands with similar semantics to <code>exec</code>. <code>&amp;</code> is a mnemonic for backgrounding process in the shell, which is sort of similar to what is going on here in the sense that the process is launched in the background as your OCaml code continues to execute, but different in the sense that you have a handle to the process and any open pipes.</p><pre class="language-ocaml"><code># let&amp; p1 = cmd [&quot;echo&quot;; &quot;foo&quot;] |&gt; pipe_out in
  let&amp; p2 = cmd [&quot;tr&quot;; &quot;a-z&quot;; &quot;A-Z&quot;] |&gt; channel_in (stdout p1) in
  ();;
FOO
- : unit = ()</code></pre><p>Note that this example actually crashes utop for reasons I don't fully understand, but it works correctly in programs.</p><p>Also be aware that <a href="Subprocess/Results/index.html#val-(let&amp;)"><code>Subprocess.Results.(let&amp;)</code></a> composes in a way similar to monadic binding, so a <code>result</code> instance must be returned. <a href="Subprocess/Results/index.html#val-exec"><code>Subprocess.Results.exec</code></a> does not behave in the same way.</p><pre class="language-ocaml"><code># Results.(
let&amp; p1 = cmd [&quot;echo&quot;; &quot;foo&quot;] |&gt; pipe_out in
let&amp; p2 = cmd [&quot;tr&quot;; &quot;a-z&quot;; &quot;A-Z&quot;] |&gt; channel_in (stdout p1) in
Ok ());;
FOO
- : (unit, Exit.t) result = Ok ()
(* yes, this one also crashes utop. *)</code></pre><h4 id="passing-around-processes"><a href="#passing-around-processes" class="anchor"></a>Passing around processes</h4><p>If working processes inside of callback functions cramps your style for some reason, you can also use <a href="Subprocess/Exec/index.html#val-exec"><code>Subprocess.Exec.exec</code></a> to pass them around. It is simply your responsibility to ensure they are cleaned up eventually.</p><pre class="language-ocaml"><code># let proc = Exec.exec (cmd [&quot;echo&quot;; &quot;foo&quot;]);;
foo
val proc : (stdin, stdout, stderr) t = process(pid: 17508, cmd(`echo foo`))
# proc.close ();;
- : Exit.t = (exited: 0, pid: 17508, cmd(`echo foo`))</code></pre><p>Each instance of <a href="Subprocess/index.html#type-t"><code>Subprocess.t</code></a> has a <code>close</code> property, which is a closure that closes any file descriptors which need to be closed and waits for the process to exit, returning an instance of <a href="Subprocess/Core/Exit/index.html#type-t"><code>Subprocess.Exit.t</code></a>.</p><p>Note that this includes pipes and any redirects of the type <code>file</code>. However, channels bound to a command are not automatically closed, since Subprocess didn't open them.</p><h4 id="non-blocking-i/o-or-&quot;working-with-multiple-pipes-for-one-process&quot;"><a href="#non-blocking-i/o-or-&quot;working-with-multiple-pipes-for-one-process&quot;" class="anchor"></a>Non-blocking I/O <i>or &quot;working with multiple pipes for one process&quot;</i></h4><p>Subprocess is not fundamentally about efficiently multiplexing I/O operations. Nonetheless working with a process with multiple pipes open Is a problem which is best solved with non-blocking I/O. Using blocking I/O in such a case can lead to deadlocks if you are waiting for I/O on one pipe while the process you've created is waiting for I/O on another pipe. Unless you've written the program yourself, you really have no control over how other processes do I/O or when they flush their buffers.</p><p>First, if you are working with multiple pipes for one process, use <a href="Subprocess/index.html#val-no_block"><code>Subprocess.no_block</code></a> to set the non-blocking flag.</p><pre class="language-ocaml"><code># let tr_upcase =
    cmd [&quot;tr&quot;; &quot;a-z&quot;; &quot;A-Z&quot;] |&gt; pipe_in |&gt; pipe_out |&gt; no_block;;
val tr_upcase : (pipe, pipe, stderr) Cmd.t =
  cmd(`tr a-z A-Z`, stdin: pipe, stdout: pipe, non-blocking)</code></pre><p>Note that there is only one flag to set, and it is applied to all pipes. In any scenario where you want to do non-blocking operations on one pipe, you will want non-blocking on all of them.</p><p>With OCaml channels, when they are set to non-blocking and you try to I/O when it's not ready, it raises <code>Sys_blocked_io</code>, so you have to catch that for any I/O operation.</p><pre class="language-ocaml"><code># let proc = Exec.exec tr_upcase;;
val proc : (pipe, pipe, stderr) t =
  process(pid: 18679,
          cmd(`tr a-z A-Z`, stdin: pipe, stdout: pipe, non-blocking))
# In_channel.input_line (stdout proc);;
Exception: Sys_blocked_io.
[stack trace omitted]</code></pre><p>As an example of how programming with non-blocking pipes looks, here follows the implementation of <a href="Subprocess/index.html#val-fold_with"><code>Subprocess.fold_with</code></a>:</p><pre class="language-ocaml"><code>let fold_with ?(sep=&quot;\n&quot;) cmd ~lines ~f ~init =
  let f' t =
    let write_line line lines =
      match Out_channel.output_string (stdin t) line with
      | exception Sys_blocked_io -&gt; Seq.cons line lines
      | () -&gt;
        match Out_channel.output_string (stdin t) sep with
        | exception Sys_blocked_io -&gt; Seq.cons &quot;&quot; lines
        | () -&gt; lines in
    let rec go lines_opt acc =
      let lines_opt' = Option.bind lines_opt @@ fun lines -&gt;
        match lines () with
        | Seq.Nil -&gt; Out_channel.close (stdin t); None
        | Seq.Cons (line, tl) -&gt; Some (write_line line tl) in
      match In_channel.input_line (stdout t) with
      | exception Sys_blocked_io -&gt; go lines_opt' acc
      | None -&gt; acc
      | Some line -&gt;
        go lines_opt' (f acc line) in
    go (Some lines) init in
  exec (cmd |&gt; pipe_in |&gt; pipe_out |&gt; no_block) ~f:f'</code></pre><p>To summarize, you have to check for <code>Sys_blocked_io</code> after every I/O operation and decide what action to take if I/O was not available on the channel you tried to communicate with.</p><p>Another approach which is not technically non-blocking, but achieves the same thing is using <code>Unix.select</code>. <a href="Subprocess/index.html#val-read_both"><code>Subprocess.read_both</code></a> uses this approach, and you may look at the source code in the repository you are curious how that might work. (It's defined in functor.ml)</p><p>Any helper function that ends with <code>_both</code> uses non-blocking I/O internally, though the helper function itself will block until all I/O is finished.</p><p>One could conceivably execute such functions in worker threads, of course, so as not to block the entire program.</p></div></body></html>
