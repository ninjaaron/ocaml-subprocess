(** A library to simplify running and working with commands on Unix.
    
    It is recommended to use {!val:Context.create} to interact with a
    running process rather than simply using {!val:create}, as this
    will ensure that the process and its associated file handles will
    be correctly shut down.
    
    In order to create a process and wait for it to exit, use
    {!val:run} or {!val:run_check}. {!val:fold} may be useful for
    iterating line-by-line over long output streams.
    
    All interfaces in this library are "safe" with untrusted input in
    the sense that a shell is never invoked and shell injection is
    impossible. Everything is implemented in terms of
    [Unix.create_process], which uses [execvp] internally. 
    
    Note that there currently is not a way to trigger early
    termination of a subprocess with this library. Perhaps there will
    be one day, when I need it. Otherwise, use the [pid] and refer to
    the [Unix] module for closing processes.
    
    examples:
    {[
      (* Command to clone this repo *)
      let clone_me = [|"git"; "clone"; "https://github.com/ninjaaron/ocaml-subprocess/"|];;
      
      (* just run the command. any output will go to stdout and stderr *)
      run clone_me;;
      
      (* silence messages *)
      run ~stderr:`Devnull clone_me;;
      
      (* get an Error type if process exist non-zero *)
      match run_check clone_me with
      | Error msg -> failwith msg
      | Ok proc -> proc
      ;;
      
      (* direct stdout to file called "log" *)
      let logfile = open_out "log" in
      run ~stdout:(`Out_channel logfile) clone_me;;
      
      (* get output lines as a list *)
      let proc = run ~stdout:`Pipe [|"cat"; "lib/subprocess.ml"|] in
      proc.stdout;;
      
      (* fold over output lines *)
      let proc, total_chars =
        fold ~stdout:`Pipe ~init:0 [|"cat"; "lib/subprocess.ml"|]
          ~f:(fun total line -> total + String.length line);;
    ]}
*)

(** This library prefers result types in general.
    This exception is only raised when there is a programming error of
    invalid input values. Such cases are annotated below.
 *)
exception Subprocess_error of string

(** the type of an opened process. stdin, stdout and stderr are
    channels with which to communicate with the process if the stream
    was set to `Pipe.
 *)
type t =
  { pid : int
  ; args : string array
  ; stdin : out_channel option
  ; stdout : in_channel option
  ; stderr : in_channel option
  }

(** the type of a process which has been closed *)
module Exit : sig 
  type t =
    { pid : int
    ; args : string array
    ; status : Unix.process_status
    }

  val to_string : t -> string
  val check : t -> (t, t) result
  val sexp_of_t : t -> Base.Sexp.t
  val t_of_sexp : Base.Sexp.t -> t
end

(** check if process [t] has finished executing. If not, return [None] *)
val poll : t -> Unix.process_status option

(** wait for process to complete, close any file handles and return
    completed process instance.
*)
val close : t -> Exit.t

(** return and [Error of string] if status code is not zero. *)
val check : t -> (Exit.t, Exit.t) result

(** Type for the stdin argument of process-creating functions in
    this library.
    
    Using [`Pipe] will generate a handle for writing to the stdin of
    the created process.
*)
type input_t =
  [ `In_channel of in_channel
  | `Pipe
  ]

(** Type for the stdout and stderr argument of process-creating functions in
    this library.
    
    Using [`Pipe] will generate a handle for reading from the specified
    stream of the created process.
    
    Using [`Devnull] will cause output to be ignored.
*)
type output_t =
  [ `Out_channel of out_channel
  | `Pipe
  | `Devnull
  ]

(** create a process with the command and arguments in an array.
    stdin, stdout and stderr are inherited from the current process
    by default. See {!type:input_t} and {!type:output_t} for more.
    
    Note that any file handles generated by [`Pipe] are wrapped as options
    and will need to be unwrapped if accessed directly.
    
    Processes should always be closed when they are no longer of use.

    It is recommended to use {!val:Context.create} to interact with a
    running process rather than simply using {!val:create}, as this
    will ensure that the process and its associated file handles will
    be correctly shut down.
*)
val create
  :  ?stdin:input_t
  -> ?stdout:output_t
  -> ?stderr: output_t
  -> string array
  -> t

(** The Context module has contains a utility function to open a
    process interact with it in the context of closure [f].
    
    The process will be closed when [f] exits or if an
    exception is raised. Returns a tuple of the clompleted process
    and the return value of [f]
*)
module Context : sig

  (** Apply a context manager to an existing process. *)
  val from : t -> f:(t -> 'a) -> Exit.t * 'a

  (** create process to interact with in the context of [f] which
      which is automatically closed after.

      See the outer [create] function for more details on specific
      arguments.
  *)
  val unchecked
    :  ?stdin:input_t
    -> ?stdout:output_t
    -> ?stderr:output_t
    -> string array
    -> f:(t -> 'a)
    -> Exit.t * 'a

  val create
    :  ?stdin:input_t
    -> ?stdout:output_t
    -> ?stderr:output_t
    -> string array
    -> f:(t -> 'a)
    -> ('a, Exit.t) result
end

val ( let* ) : t -> (t -> ('a, Exit.t) result) -> ('a, Exit.t) result

(** write a string to the stdin of the process. 
    raise [Stdlib.Invalid_argument] if stdin was not opened with [`Pipe]
*)
val write_stdin : t -> string -> unit

(** read a line from the stdin of the process. 
    @return None  if end of file is reached or stdin wasn't opened
    with [`Pipe].
*)
val line : t -> string option

(** Same as [line], but for stderr *)
val stderr_line : t -> string option

(** Read lines from stdout as a [Seq.t] *)
val lines : t -> string Seq.t

(** Read lines from stderr as a [Seq.t] *)
val stderr_lines : t -> string Seq.t

(** Output type of {!val:run}, {!val:run_check} and {!val:write}.
    [proc] is the completed process. stdout and stderr are lists of
    strings correspoding to the output of those streams from the
    process. They will be empty unless the corresponding stream was
    set to [`Pipe].
*)
module Run : sig
  type t =
    { proc: Exit.t
    ; stdout: string list
    ; stderr: string list
    }

  (** Creates a process, waits for it to finish and returns the 
      completed process and any collected output See {!type:run_t} for
      more details.
  *)
  val unchecked
    :  ?stdin:in_channel
    -> ?stdout:output_t
    -> ?stderr:output_t
    -> string array
    -> t

  (** Execute a command with {!val:run} and then check the status
      code. Returns [Error of string] if non-zero.
  *) 
  val run
    :  ?stdin:in_channel
    -> ?stdout:output_t
    -> ?stderr:output_t
    -> string array
    -> (t, Exit.t) result

  (** Similar to {!val:run}, but writes the [input] string to stdin. *)
  val filter
    :  ?stdout:output_t
    -> ?stderr:output_t
    -> string array
    -> input: string
    -> t
end

(** Execute a command with {!val:run} and then check the status
    code. Returns [Error of string] if non-zero.
*) 
val run
  :  ?stdin:in_channel
  -> ?stdout:output_t
  -> ?stderr:output_t
  -> string array
  -> (Run.t, Exit.t) result

(** Create a process with either stdout or stderr set to [`Pipe], and
    fold over the lines of output.
    Returns a tuple of the {!type:completed} process and the
    accumulated output.
    
    @raise Subprocess_error if {i neither or both} stdin and stderr ar
    set to [`Pipe]. Exactly one of these streams may be used.
*)
val fold
  : ?stdin:in_channel
  -> ?stderr:bool
  -> string array
  -> f:('a -> string -> 'a)
  -> init:'a
  -> Exit.t * 'a

val or_error :  ('a, Exit.t) result -> 'a Base.Or_error.t
val string_error : ('a, Exit.t) result -> ('a, string) Result.t
