<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (subprocess.index)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">Index</a> &#x00BB; subprocess</nav><header class="odoc-preamble"><h2 id="subprocess:-abstractions-for-io-with-unix-processes"><a href="#subprocess:-abstractions-for-io-with-unix-processes" class="anchor"></a>Subprocess: abstractions for IO with unix processes</h2><p><a href="Subprocess/index.html"><code>Subprocess</code></a> is a module which attempts to make working with unix processes in OCaml safer and a bit simpler. Working with OS interfaces is never wholly safe, and the goal of this library is not to eliminate all failure cases when working with processes---for doing so would require reimplementing all of the IO in the standard library. (Maybe in Subproces2?)</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#safety-features">Safety features</a></li><li><a href="#extras">Extras</a></li></ul></nav></div><div class="odoc-content"><h3 id="safety-features"><a href="#safety-features" class="anchor"></a>Safety features</h3><p>To this end, commands in Subprocess never recieve a shell. We've had enough injection CEVs in the past several decades that it's time to stop giving our commands a shell. I realize redirection tends to be a bit easier to be a bit easier with a shell, but Subprocess provides combinators to make it as easy as possible (but no easier!) to do IO redirection---and indeed, this is the main point of the library.</p><p>Another &quot;feature not a bug&quot; of Subprocess is that, by default, a non-zero exit status is considered a failure will produce an error on in OCaml. In the top-level functions of the <a href="Subprocess/index.html"><code>Subprocess</code></a> module, this means raising an exception. If you, like me, prefer to handle errors with result types, the <a href="Subprocess/Results/index.html"><code>Subprocess.Results</code></a> module is provided to represent non-zero exit status as an <code>Error of</code> <a href="Subprocess/Core/Exit/index.html#type-t"><code>Subprocess.Exit.t</code></a>. A combinator is provided convert this to <code>Error of string</code> for better composition with other result types in the context of monadic binding.</p><p>However, I realize that a non-zero exit status is not always an error, and for this, the <a href="Subprocess/Unchecked/index.html"><code>Subprocess.Unchecked</code></a> module is provided. This module is also useful if you are interested in the output of a process regardless of the exit status.</p><p>Finally, Suprocess attempts to avoid making the user handle closing processes and pipes expliciitly by providing several functions which simply read process output, close all pipes and wait for the process to exit before returning the output (or error). There is also family of fold functions which fold over line output from a running process, but clean everything up before returning.</p><p>For running process interaction, the running process is passed to a user-provided function and everything is properly closed when the function exits---either by being fully evaluated or by raising an exception.</p><p>If for some reason you need to pass around a live process in a wider context, <a href="Subprocess/Exec/index.html#val-exec"><code>Subprocess.Exec.exec</code></a> makes this possible, but you have to clean up your own mess at that point.</p><h3 id="extras"><a href="#extras" class="anchor"></a>Extras</h3><p>Subprocess generally does not use many any opaque types and practically everything has a pretty printer for easier debugging. The lack of opaque types is not an <i>invitation</i> to go digging into the implementation details <i>which are subject to change</i>, but rather an acknowledgement that no abstraction is perfect and there may at times valid reasons to dig into them.</p><p>Subprocess supports non-blocking IO, but it does not provide direct compatibility layers with popular OCaml ascynchronous IO libraries like lwt and eio, which typically provide their own process abstractions. Neither does Subprocess provide its own event loop. The user must handle non-blocking IO operations and process polling manually where non-blocking behavior is desired. It is not different from handling non-blocking IO in the OCaml standard library and examples will be provided here where relevant.</p></div></body></html>
